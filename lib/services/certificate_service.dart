import './database_helper.dart';
import 'package:file_picker/file_picker.dart';
import 'package:path/path.dart' as path;
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'dart:io';
import '../models/certificate.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:pdf/pdf.dart';
import 'package:path_provider/path_provider.dart';

class CertificateService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseStorage _storage = FirebaseStorage.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // Collection reference
  CollectionReference<Map<String, dynamic>> get _certificatesCollection =>
      _firestore.collection('certificates');

  // Get current user
  User? get currentUser => _auth.currentUser;

  // Create a new certificate (auto-generated or manual upload)
  Future<Certificate?> createCertificate({
    required String certName,
    required String issuer,
    required String recipientName,
    required String certificateType,
    required DateTime issueDate,
    DateTime? expiryDate,
    String? description,
    String? additionalInfo,
    File? certificateFile, // For manual PDF upload
    bool isAutoGenerated = true,
    String? signature,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final user = currentUser;
      if (user == null) throw Exception('User not authenticated');

      final certId = Certificate.generateCertId();
      final now = DateTime.now();
      String? fileUrl;
      String? fileName;
      double? fileSize;
      String? fileType;
      File? fileToUpload = certificateFile;

      // If auto-generated, create a PDF and upload it
      if (isAutoGenerated) {
        final pdfFile = await _generateCertificatePdf(
          certId: certId,
          certName: certName,
          issuer: issuer,
          recipientName: recipientName,
          certificateType: certificateType,
          issueDate: issueDate,
          expiryDate: expiryDate,
          description: description,
          additionalInfo: additionalInfo,
          signature: signature,
        );
        fileToUpload = pdfFile;
      }

      // Handle file upload if provided (manual upload or generated PDF)
      if (fileToUpload != null) {
        final uploadResult = await _uploadCertificateFile(fileToUpload, certId);
        fileUrl = uploadResult['url'];
        fileName = uploadResult['fileName'];
        fileSize = uploadResult['fileSize'];
        fileType = uploadResult['fileType'];
      }

      // Create certificate object
      final certificate = Certificate(
        certId: certId,
        certName: certName,
        issuer: issuer,
        recipientName: recipientName,
        certificateType: certificateType,
        issueDate: issueDate,
        expiryDate: expiryDate,
        description: description,
        additionalInfo: additionalInfo,
        fileUrl: fileUrl,
        fileName: fileName,
        fileSize: fileSize,
        fileType: fileType,
        isAutoGenerated: isAutoGenerated,
        createdBy: user.uid,
        createdByEmail: user.email ?? '',
        createdAt: now,
        updatedAt: now,
        status: 'active',
        signature: signature,
        metadata: metadata,
      );

      // Save to Firestore
      final docRef = await _certificatesCollection.add(certificate.toMap());

      // Return certificate with document ID
      return certificate.copyWith(id: docRef.id);
    } catch (e) {
      print('Error creating certificate: $e');
      rethrow;
    }
  }

  // Generate a PDF for the certificate
  Future<File> _generateCertificatePdf({
    required String certId,
    required String certName,
    required String issuer,
    required String recipientName,
    required String certificateType,
    required DateTime issueDate,
    DateTime? expiryDate,
    String? description,
    String? additionalInfo,
    String? signature,
  }) async {
    final pdf = pw.Document();
    pdf.addPage(
      pw.Page(
        pageFormat: PdfPageFormat.a4,
        build: (pw.Context context) {
          return pw.Container(
            padding: const pw.EdgeInsets.all(32),
            child: pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.center,
              children: [
                pw.Text(
                  'Certificate of Achievement',
                  style: pw.TextStyle(
                    fontSize: 28,
                    fontWeight: pw.FontWeight.bold,
                  ),
                ),
                pw.SizedBox(height: 24),
                pw.Text(
                  'Certificate ID: $certId',
                  style: pw.TextStyle(fontSize: 12, color: PdfColors.grey),
                ),
                pw.SizedBox(height: 24),
                pw.Text(
                  certName,
                  style: pw.TextStyle(
                    fontSize: 22,
                    fontWeight: pw.FontWeight.bold,
                  ),
                ),
                pw.SizedBox(height: 16),
                pw.Text('Awarded to', style: pw.TextStyle(fontSize: 16)),
                pw.SizedBox(height: 8),
                pw.Text(
                  recipientName,
                  style: pw.TextStyle(
                    fontSize: 20,
                    fontWeight: pw.FontWeight.bold,
                    color: PdfColors.blue,
                  ),
                ),
                pw.SizedBox(height: 16),
                pw.Text(
                  'Issued by: $issuer',
                  style: pw.TextStyle(fontSize: 16),
                ),
                pw.SizedBox(height: 8),
                pw.Text(
                  'Type: $certificateType',
                  style: pw.TextStyle(fontSize: 16),
                ),
                pw.Text(
                  'Issue Date: {issueDate.day}/${issueDate.month}/${issueDate.year}',
                  style: pw.TextStyle(fontSize: 16),
                ),
                if (expiryDate != null)
                  pw.Text(
                    'Expiry Date: ${expiryDate.day}/${expiryDate.month}/${expiryDate.year}',
                    style: pw.TextStyle(fontSize: 16),
                  ),
                if (description != null && description.isNotEmpty) ...[
                  pw.SizedBox(height: 16),
                  pw.Text(
                    'Description:',
                    style: pw.TextStyle(
                      fontSize: 14,
                      fontWeight: pw.FontWeight.bold,
                    ),
                  ),
                  pw.Text(description, style: pw.TextStyle(fontSize: 14)),
                ],
                if (additionalInfo != null && additionalInfo.isNotEmpty) ...[
                  pw.SizedBox(height: 16),
                  pw.Text(
                    'Additional Info:',
                    style: pw.TextStyle(
                      fontSize: 14,
                      fontWeight: pw.FontWeight.bold,
                    ),
                  ),
                  pw.Text(additionalInfo, style: pw.TextStyle(fontSize: 14)),
                ],
                if (signature != null && signature.isNotEmpty) ...[
                  pw.SizedBox(height: 32),
                  pw.Text(
                    'Signature:',
                    style: pw.TextStyle(
                      fontSize: 14,
                      fontWeight: pw.FontWeight.bold,
                    ),
                  ),
                  pw.Text(signature, style: pw.TextStyle(fontSize: 14)),
                ],
                pw.Spacer(),
                pw.Divider(),
                pw.Text(
                  'Generated by CertiSafe',
                  style: pw.TextStyle(fontSize: 10, color: PdfColors.grey),
                ),
              ],
            ),
          );
        },
      ),
    );
    final output = await getTemporaryDirectory();
    final file = File('${output.path}/$certId.pdf');
    await file.writeAsBytes(await pdf.save());
    return file;
  }

  // Upload certificate file to Firebase Storage
  Future<Map<String, dynamic>> _uploadCertificateFile(
    File file,
    String certId,
  ) async {
    try {
      print('Uploading file: ${file.path}');
      print('File exists: ${file.existsSync()}');
      if (!file.existsSync()) {
        throw Exception('Selected file does not exist.');
      }
      final fileName = file.path.split('/').last;
      final fileExtension = fileName.split('.').last.toLowerCase();

      // Validate file type
      if (![
        'pdf',
        'jpg',
        'jpeg',
        'png',
        'doc',
        'docx',
      ].contains(fileExtension)) {
        throw Exception(
          'Invalid file type. Only PDF, JPG, PNG, DOC, DOCX are allowed.',
        );
      }
      final storageRef = _storage.ref().child('certificates/$certId/$fileName');
      final uploadTask = storageRef.putFile(file);
      final snapshot = await uploadTask;
      final downloadUrl = await snapshot.ref.getDownloadURL();

      // Get file size synchronously
      final fileSize = await file.length();

      return {
        'url': downloadUrl,
        'fileName': fileName,
        'fileSize': fileSize.toDouble(),
        'fileType': fileExtension,
      };
    } catch (e) {
      print('Error uploading certificate file: $e');
      rethrow;
    }
  }

  Future<Certificate?> addCertificate() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx'],
        allowMultiple: false,
      );

      if (result != null) {
        final file = File(result.files.single.path!);
        final fileName = result.files.single.name;
        final fileSize = await file.length();
        final fileExtension = path.extension(fileName).toLowerCase();

        // Determine file type
        String fileType;
        switch (fileExtension) {
          case '.pdf':
            fileType = 'PDF';
            break;
          case '.jpg':
          case '.jpeg':
          case '.png':
            fileType = 'Image';
            break;
          case '.doc':
          case '.docx':
            fileType = 'Document';
            break;
          default:
            fileType = 'Other';
        }

        // Copy file to app directory
        final certDir = await _getCertificateDirectory();
        final uniqueFileName =
            '${DateTime.now().millisecondsSinceEpoch}_$fileName';
        final newFilePath = path.join(certDir, uniqueFileName);
        await file.copy(newFilePath);

        // Create certificate record with required fields
        final certificate = Certificate(
          certId: Certificate.generateCertId(),
          certName: fileName,
          issuer: '',
          recipientName: '',
          certificateType: fileType,
          issueDate: DateTime.now(),
          expiryDate: null,
          description:
              'Certificate uploaded on ${DateTime.now().toString().split(' ')[0]}',
          additionalInfo: null,
          filePath: newFilePath,
          fileUrl: null,
          fileName: fileName,
          fileSize: fileSize.toDouble(),
          fileType: fileType,
          isAutoGenerated: false,
          createdBy: '',
          createdByEmail: '',
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
          status: 'active',
          signature: null,
          metadata: null,
          firebaseUrl: null,
        );

        // Save to database
        final id = await _databaseHelper.insertCertificate(certificate);
        return certificate.copyWith(id: id.toString());
      }
      return null;
    } catch (e) {
      print('Error uploading certificate file: $e');
      rethrow;
    }
  }

  // Add more methods as needed (getAllCertificates, deleteCertificate, etc.)
}
